import { randomBytes } from "@fuel-ts/keystore";
import {
  coinQuantityfy,
  CoinQuantityLike,
  Provider,
  ScriptTransactionRequest,
} from "@fuel-ts/providers";
import { Wallet, WalletUnlocked } from "@fuel-ts/wallet";
import { ContractFactory, NativeAssetId, hexlify, hexZeroPad } from "fuels";
import * as fs from "fs";
import * as path from "path";
import {
  PricesAbi as PricesContract,
  PricesAbi__factory,
} from "../prices/autogenerated";
import { U256Output } from "../prices/autogenerated/PricesAbi";

export type PricesOutput = [
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output,
  U256Output
];

export interface PricesParameters {
  signers: string[];
  signerCountThreshold: number;
  fakeTimestamp?: number;
}

export const readTestData = (filename: string): string[] => {
  return splitPayloadData(
    fs
      .readFileSync(path.join(__dirname, `../sample-data/${filename}.hex`))
      .toString()
  );
};

export const deployPricesContract = async (
  parameters: PricesParameters,
  provider?: string | Provider
): Promise<PricesContract> => {
  const bytecode = fs.readFileSync(
    path.join(__dirname, "../prices/autogenerated/prices.bin")
  );

  const wallet = await generateTestWallet(provider, [[1_000, NativeAssetId]]);
  const factory = new ContractFactory(bytecode, PricesAbi__factory.abi, wallet);
  let storageSlots = getStorageSlots(parameters);

  let contract = (await factory.deployContract({
    storageSlots,
  })) as unknown as PricesContract;

  await contract.functions
    .init(
      parameters.signers.map((signer) => hexZeroPad(signer, 32)),
      parameters.signerCountThreshold,
      0
    )
    .call();

  return contract;
};

const generateTestWallet = async (
  provider?: string | Provider,
  quantities?: CoinQuantityLike[]
): Promise<WalletUnlocked> => {
  const wallet = Wallet.generate({ provider });
  if (quantities) {
    await seedTestWallet(wallet, quantities);
  }
  return wallet;
};

const seedTestWallet = async (
  wallet: WalletUnlocked,
  quantities: CoinQuantityLike[]
) => {
  const genesisWallet = new WalletUnlocked(
    process.env.GENESIS_SECRET || randomBytes(32),
    wallet.provider
  );

  // Connect to the same Provider as wallet
  const resources = await genesisWallet.getResourcesToSpend(quantities);

  // Create transaction
  const request = new ScriptTransactionRequest({
    gasLimit: 10000,
    gasPrice: 1,
  });

  request.addResources(resources);

  quantities
    .map(coinQuantityfy)
    .forEach(({ amount, assetId }) =>
      request.addCoinOutput(wallet.address, amount, assetId)
    );
  const response = await genesisWallet.sendTransaction(request);

  await response.wait();
};

const getStorageSlots = (parameters: PricesParameters | undefined) => {
  let storageSlots = [];

  if (parameters != null) {
    if (parameters.fakeTimestamp != null) {
      storageSlots.push({
        key: "0x66616b655f74696d657374616d70",
        value: hexlify(parameters.fakeTimestamp),
      });
    }
  }

  return storageSlots.map(({ key, value }) => {
    return {
      key: hexZeroPad(key, 32) as string,
      value: hexZeroPad(value, 32) as string,
    };
  });
};

const splitPayloadData = (payloadHex: string): string[] => {
  let payloadData = [];
  for (let i = 2; i < Array.from(payloadHex).length - 1; i++) {
    if (i % 2 == 1) {
      continue;
    }
    payloadData[i / 2 - 1] = `0x${payloadHex[i]}${payloadHex[i + 1]}`;
  }

  return payloadData;
};
